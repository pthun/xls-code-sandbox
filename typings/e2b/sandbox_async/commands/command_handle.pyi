"""
This type stub file was generated by pyright.
"""

from typing import Any, AsyncGenerator, Callable, Coroutine, Optional, Union
from e2b.envd.process import process_pb2
from e2b.sandbox.commands.command_handle import CommandResult, PtyOutput, Stderr, Stdout
from e2b.sandbox_async.utils import OutputHandler

class AsyncCommandHandle:
    """
    Command execution handle.

    It provides methods for waiting for the command to finish, retrieving stdout/stderr, and killing the command.
    """
    @property
    def pid(self): # -> int:
        """
        Command process ID.
        """
        ...
    
    @property
    def stdout(self): # -> str:
        """
        Command stdout output.
        """
        ...
    
    @property
    def stderr(self): # -> str:
        """
        Command stderr output.
        """
        ...
    
    @property
    def error(self): # -> str | None:
        """
        Command execution error message.
        """
        ...
    
    @property
    def exit_code(self): # -> int | None:
        """
        Command execution exit code.

        `0` if the command finished successfully.

        It is `None` if the command is still running.
        """
        ...
    
    def __init__(self, pid: int, handle_kill: Callable[[], Coroutine[Any, Any, bool]], events: AsyncGenerator[Union[process_pb2.StartResponse, process_pb2.ConnectResponse], Any], on_stdout: Optional[OutputHandler[Stdout]] = ..., on_stderr: Optional[OutputHandler[Stderr]] = ..., on_pty: Optional[OutputHandler[PtyOutput]] = ...) -> None:
        ...
    
    async def disconnect(self) -> None:
        """
        Disconnects from the command.

        The command is not killed, but SDK stops receiving events from the command.
        You can reconnect to the command using `sandbox.commands.connect` method.
        """
        ...
    
    async def wait(self) -> CommandResult:
        """
        Wait for the command to finish and return the result.
        If the command exits with a non-zero exit code, it throws a `CommandExitException`.

        :return: `CommandResult` result of command execution
        """
        ...
    
    async def kill(self) -> bool:
        """
        Kills the command.

        It uses `SIGKILL` signal to kill the command

        :return: `True` if the command was killed successfully, `False` if the command was not found
        """
        ...
    


