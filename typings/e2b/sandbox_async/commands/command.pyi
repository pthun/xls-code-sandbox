"""
This type stub file was generated by pyright.
"""

import httpcore
from typing import Dict, List, Literal, Optional, Union, overload
from e2b.connection_config import ConnectionConfig, Username
from e2b.sandbox.commands.main import ProcessInfo
from e2b.sandbox.commands.command_handle import CommandResult
from e2b.sandbox_async.commands.command_handle import AsyncCommandHandle, Stderr, Stdout
from e2b.sandbox_async.utils import OutputHandler

class Commands:
    """
    Module for executing commands in the sandbox.
    """
    def __init__(self, envd_api_url: str, connection_config: ConnectionConfig, pool: httpcore.AsyncConnectionPool) -> None:
        ...
    
    async def list(self, request_timeout: Optional[float] = ...) -> List[ProcessInfo]:
        """
        Lists all running commands and PTY sessions.

        :param request_timeout: Timeout for the request in **seconds**

        :return: List of running commands and PTY sessions
        """
        ...
    
    async def kill(self, pid: int, request_timeout: Optional[float] = ...) -> bool:
        """
        Kill a running command specified by its process ID.
        It uses `SIGKILL` signal to kill the command.

        :param pid: Process ID of the command. You can get the list of processes using `sandbox.commands.list()`
        :param request_timeout: Timeout for the request in **seconds**

        :return: `True` if the command was killed, `False` if the command was not found
        """
        ...
    
    async def send_stdin(self, pid: int, data: str, request_timeout: Optional[float] = ...) -> None:
        """
        Send data to command stdin.

        :param pid Process ID of the command. You can get the list of processes using `sandbox.commands.list()`.
        :param data: Data to send to the command
        :param request_timeout: Timeout for the request in **seconds**
        """
        ...
    
    @overload
    async def run(self, cmd: str, background: Union[Literal[False], None] = ..., envs: Optional[Dict[str, str]] = ..., user: Username = ..., cwd: Optional[str] = ..., on_stdout: Optional[OutputHandler[Stdout]] = ..., on_stderr: Optional[OutputHandler[Stderr]] = ..., timeout: Optional[float] = ..., request_timeout: Optional[float] = ...) -> CommandResult:
        """
        Start a new command and wait until it finishes executing.

        :param cmd: Command to execute
        :param background: **`False` if the command should be executed in the foreground**, `True` if the command should be executed in the background
        :param envs: Environment variables used for the command
        :param user: User to run the command as
        :param cwd: Working directory to run the command
        :param on_stdout: Callback for command stdout output
        :param on_stderr: Callback for command stderr output
        :param timeout: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
        :param request_timeout: Timeout for the request in **seconds**

        :return: `CommandResult` result of the command execution
        """
        ...
    
    @overload
    async def run(self, cmd: str, background: Literal[True], envs: Optional[Dict[str, str]] = ..., user: Username = ..., cwd: Optional[str] = ..., on_stdout: Optional[OutputHandler[Stdout]] = ..., on_stderr: Optional[OutputHandler[Stderr]] = ..., timeout: Optional[float] = ..., request_timeout: Optional[float] = ...) -> AsyncCommandHandle:
        """
        Start a new command and return a handle to interact with it.

        :param cmd: Command to execute
        :param background: `False` if the command should be executed in the foreground, **`True` if the command should be executed in the background**
        :param envs: Environment variables used for the command
        :param user: User to run the command as
        :param cwd: Working directory to run the command
        :param on_stdout: Callback for command stdout output
        :param on_stderr: Callback for command stderr output
        :param timeout: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
        :param request_timeout: Timeout for the request in **seconds**

        :return: `AsyncCommandHandle` handle to interact with the running command
        """
        ...
    
    async def run(self, cmd: str, background: Union[bool, None] = ..., envs: Optional[Dict[str, str]] = ..., user: Username = ..., cwd: Optional[str] = ..., on_stdout: Optional[OutputHandler[Stdout]] = ..., on_stderr: Optional[OutputHandler[Stderr]] = ..., timeout: Optional[float] = ..., request_timeout: Optional[float] = ...): # -> AsyncCommandHandle | CommandResult:
        ...
    
    async def connect(self, pid: int, timeout: Optional[float] = ..., request_timeout: Optional[float] = ..., on_stdout: Optional[OutputHandler[Stdout]] = ..., on_stderr: Optional[OutputHandler[Stderr]] = ...) -> AsyncCommandHandle:
        """
        Connects to a running command.
        You can use `AsyncCommandHandle.wait()` to wait for the command to finish and get execution results.

        :param pid: Process ID of the command to connect to. You can get the list of processes using `sandbox.commands.list()`
        :param request_timeout: Request timeout in **seconds**
        :param timeout: Timeout for the command connection in **seconds**. Using `0` will not limit the command connection time
        :param on_stdout: Callback for command stdout output
        :param on_stderr: Callback for command stderr output

        :return: `AsyncCommandHandle` handle to interact with the running command
        """
        ...
    


