"""
This type stub file was generated by pyright.
"""

import json
from dataclasses import dataclass
from typing import Any, Awaitable, Callable, Dict, Iterable, List, Optional, TypeVar, Union
from httpx import Response
from .charts import Chart

T = TypeVar("T")
OutputHandler = Union[Callable[[T], Any], Callable[[T], Awaitable[Any]],]
logger = ...
@dataclass
class OutputMessage:
    """
    Represents an output message from the sandbox code execution.
    """
    line: str
    timestamp: int
    error: bool = ...
    def __str__(self) -> str:
        ...
    


@dataclass
class ExecutionError:
    """
    Represents an error that occurred during the execution of a cell.
    The error contains the name of the error, the value of the error, and the traceback.
    """
    name: str
    value: str
    traceback: str
    def __init__(self, name: str, value: str, traceback: str, **kwargs) -> None:
        ...
    
    def to_json(self) -> str:
        """
        Returns the JSON representation of the Error object.
        """
        ...
    


class MIMEType(str):
    """
    Represents a MIME type.
    """
    ...


@dataclass
class Result:
    """
    Represents the data to be displayed as a result of executing a cell in a Jupyter notebook.
    The result is similar to the structure returned by ipython kernel: https://ipython.readthedocs.io/en/stable/development/execution.html#execution-semantics

    The result can contain multiple types of data, such as text, images, plots, etc. Each type of data is represented
    as a string, and the result can contain multiple types of data. The display calls don't have to have text representation,
    for the actual result the representation is always present for the result, the other representations are always optional.
    """
    def __getitem__(self, item): # -> Any:
        ...
    
    text: Optional[str] = ...
    html: Optional[str] = ...
    markdown: Optional[str] = ...
    svg: Optional[str] = ...
    png: Optional[str] = ...
    jpeg: Optional[str] = ...
    pdf: Optional[str] = ...
    latex: Optional[str] = ...
    json: Optional[dict] = ...
    javascript: Optional[str] = ...
    data: Optional[dict] = ...
    chart: Optional[Chart] = ...
    is_main_result: bool = ...
    extra: Optional[dict] = ...
    def __init__(self, text: Optional[str] = ..., html: Optional[str] = ..., markdown: Optional[str] = ..., svg: Optional[str] = ..., png: Optional[str] = ..., jpeg: Optional[str] = ..., pdf: Optional[str] = ..., latex: Optional[str] = ..., json: Optional[dict] = ..., javascript: Optional[str] = ..., data: Optional[dict] = ..., chart: Optional[dict] = ..., is_main_result: bool = ..., extra: Optional[dict] = ..., **kwargs) -> None:
        ...
    
    def formats(self) -> Iterable[str]:
        """
        Returns all available formats of the result.

        :return: All available formats of the result in MIME types.
        """
        ...
    
    def __str__(self) -> Optional[str]:
        """
        Returns the text representation of the data.

        :return: The text representation of the data.
        """
        ...
    
    def __repr__(self) -> str:
        ...
    


@dataclass(repr=False)
class Logs:
    """
    Data printed to stdout and stderr during execution, usually by print statements, logs, warnings, subprocesses, etc.
    """
    stdout: List[str] = ...
    stderr: List[str] = ...
    def __init__(self, stdout: List[str] = ..., stderr: List[str] = ..., **kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def to_json(self) -> str:
        """
        Returns the JSON representation of the Logs object.
        """
        ...
    


def serialize_results(results: List[Result]) -> List[Dict[str, str]]:
    """
    Serializes the results to JSON.
    """
    ...

@dataclass(repr=False)
class Execution:
    """
    Represents the result of a cell execution.
    """
    results: List[Result] = ...
    logs: Logs = ...
    error: Optional[ExecutionError] = ...
    execution_count: Optional[int] = ...
    def __init__(self, results: List[Result] = ..., logs: Logs = ..., error: Optional[ExecutionError] = ..., execution_count: Optional[int] = ..., **kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def text(self) -> Optional[str]:
        """
        Returns the text representation of the result.

        :return: The text representation of the result.
        """
        ...
    
    def to_json(self) -> str:
        """
        Returns the JSON representation of the Execution object.
        """
        ...
    


async def aextract_exception(res: Response): # -> NotFoundException | TimeoutException | SandboxException | None:
    ...

def extract_exception(res: Response): # -> NotFoundException | TimeoutException | SandboxException | None:
    ...

def format_exception(res: Response): # -> NotFoundException | TimeoutException | SandboxException | None:
    ...

def parse_output(execution: Execution, output: str, on_stdout: Optional[OutputHandler[OutputMessage]] = ..., on_stderr: Optional[OutputHandler[OutputMessage]] = ..., on_result: Optional[OutputHandler[Result]] = ..., on_error: Optional[OutputHandler[ExecutionError]] = ...): # -> None:
    ...

@dataclass
class Context:
    """
    Represents a context for code execution.
    """
    id: str
    language: str
    cwd: str
    def __init__(self, context_id: str, language: str, cwd: str, **kwargs) -> None:
        ...
    
    @classmethod
    def from_json(cls, data: Dict[str, str]): # -> Self:
        ...
    


